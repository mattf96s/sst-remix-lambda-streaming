diff --git a/constructs/RemixSite.js b/constructs/RemixSite.js
index b979e493b1e4311bfa573de2eccb75c9d40903d6..d23b09d96909bab3da322d7698652518f6506f51 100644
--- a/constructs/RemixSite.js
+++ b/constructs/RemixSite.js
@@ -21,127 +21,157 @@ const __dirname = url.fileURLToPath(new URL(".", import.meta.url));
  * ```
  */
 export class RemixSite extends SsrSite {
-    initBuildConfig() {
-        const { path: sitePath } = this.props;
-        const configDefaults = {
-            assetsBuildDirectory: "public/build",
-            publicPath: "/build/",
-            serverBuildPath: "build/index.js",
-            serverModuleFormat: "cjs",
-            serverPlatform: "node",
-        };
-        // Validate config path
-        const configPath = path.resolve(sitePath, "remix.config.js");
-        if (!fs.existsSync(configPath)) {
-            throw new Error(`Could not find "remix.config.js" at expected path "${configPath}".`);
-        }
-        // Load config
-        const userConfig = require(configPath);
-        const config = {
-            ...configDefaults,
-            ...userConfig,
-        };
-        // Validate config
-        Object.keys(configDefaults).forEach((key) => {
-            const k = key;
-            if (config[k] !== configDefaults[k]) {
-                throw new Error(`RemixSite: remix.config.js "${key}" must be "${configDefaults[k]}".`);
-            }
-        });
-        return {
-            typesPath: ".",
-            serverBuildOutputFile: "build/index.js",
-            clientBuildOutputDir: "public",
-            clientBuildVersionedSubDir: "build",
-        };
-    }
-    createServerLambdaBundle(wrapperFile) {
-        // Create a Lambda@Edge handler for the Remix server bundle.
-        //
-        // Note: Remix does perform their own internal ESBuild process, but it
-        // doesn't bundle 3rd party dependencies by default. In the interest of
-        // keeping deployments seamless for users we will create a server bundle
-        // with all dependencies included. We will still need to consider how to
-        // address any need for external dependencies, although I think we should
-        // possibly consider this at a later date.
-        // In this path we are assuming that the Remix build only outputs the
-        // "core server build". We can safely assume this as we have guarded the
-        // remix.config.js to ensure it matches our expectations for the build
-        // configuration.
-        // We need to ensure that the "core server build" is wrapped with an
-        // appropriate Lambda@Edge handler. We will utilise an internal asset
-        // template to create this wrapper within the "core server build" output
-        // directory.
-        // Ensure build directory exists
-        const buildPath = path.join(this.props.path, "build");
-        fs.mkdirSync(buildPath, { recursive: true });
-        // Copy the server lambda handler
-        fs.copyFileSync(path.resolve(__dirname, `../support/remix-site-function/${wrapperFile}`), path.join(buildPath, "server.js"));
-        // Copy the Remix polyfil to the server build directory
-        //
-        // Note: We need to ensure that the polyfills are injected above other code that
-        // will depend on them. Importing them within the top of the lambda code
-        // doesn't appear to guarantee this, we therefore leverage ESBUild's
-        // `inject` option to ensure that the polyfills are injected at the top of
-        // the bundle.
-        const polyfillDest = path.join(buildPath, "polyfill.js");
-        fs.copyFileSync(path.resolve(__dirname, "../support/remix-site-function/polyfill.js"), polyfillDest);
-        return {
-            handler: path.join(buildPath, "server.handler"),
-            esbuild: { inject: [polyfillDest] },
-        };
-    }
-    createFunctionForRegional() {
-        const { runtime, timeout, memorySize, permissions, environment, bind, nodejs, cdk, } = this.props;
-        const { handler, esbuild } = this.createServerLambdaBundle("regional-server.js");
-        return new SsrFunction(this, `ServerFunction`, {
-            description: "Server handler for Remix",
-            handler,
-            runtime,
-            memorySize,
-            timeout,
-            nodejs: {
-                format: "cjs",
-                ...nodejs,
-                esbuild: {
-                    ...esbuild,
-                    ...nodejs?.esbuild,
-                    inject: [...(nodejs?.esbuild?.inject || []), ...esbuild.inject],
-                },
-            },
-            bind,
-            environment,
-            permissions,
-            ...cdk?.server,
-        });
-    }
-    createFunctionForEdge() {
-        const { runtime, timeout, memorySize, bind, permissions, environment, nodejs, } = this.props;
-        const { handler, esbuild } = this.createServerLambdaBundle("edge-server.js");
-        return new EdgeFunction(this, `Server`, {
-            scopeOverride: this,
-            handler,
-            runtime,
-            timeout,
-            memorySize,
-            bind,
-            environment,
-            permissions,
-            nodejs: {
-                format: "cjs",
-                ...nodejs,
-                esbuild: {
-                    ...esbuild,
-                    ...nodejs?.esbuild,
-                    inject: [...(nodejs?.esbuild?.inject || []), ...esbuild.inject],
-                },
-            },
-        });
-    }
-    getConstructMetadata() {
-        return {
-            type: "RemixSite",
-            ...this.getConstructMetadataBase(),
-        };
+  initBuildConfig() {
+    const { path: sitePath } = this.props;
+    const configDefaults = {
+      assetsBuildDirectory: "public/build",
+      publicPath: "/build/",
+      serverBuildPath: "build/index.js",
+      serverModuleFormat: "esm",
+      serverPlatform: "node",
+    };
+    // Validate config path
+    const configPath = path.resolve(sitePath, "remix.config.js");
+    if (!fs.existsSync(configPath)) {
+      throw new Error(
+        `Could not find "remix.config.js" at expected path "${configPath}".`
+      );
     }
+    // Load config
+    const userConfig = import(configPath).then((module) => module.default);
+    const config = {
+      ...configDefaults,
+      ...userConfig,
+    };
+
+    // Validate config
+    Object.keys(configDefaults).forEach((key) => {
+      const k = key;
+      if (config[k] !== configDefaults[k]) {
+        throw new Error(
+          `RemixSite: remix.config.js "${key}" must be "${configDefaults[k]}".`
+        );
+      }
+    });
+    return {
+      typesPath: ".",
+      serverBuildOutputFile: "build/index.js",
+      clientBuildOutputDir: "public",
+      clientBuildVersionedSubDir: "build",
+    };
+  }
+  createServerLambdaBundle(wrapperFile) {
+    // Create a Lambda@Edge handler for the Remix server bundle.
+    //
+    // Note: Remix does perform their own internal ESBuild process, but it
+    // doesn't bundle 3rd party dependencies by default. In the interest of
+    // keeping deployments seamless for users we will create a server bundle
+    // with all dependencies included. We will still need to consider how to
+    // address any need for external dependencies, although I think we should
+    // possibly consider this at a later date.
+    // In this path we are assuming that the Remix build only outputs the
+    // "core server build". We can safely assume this as we have guarded the
+    // remix.config.js to ensure it matches our expectations for the build
+    // configuration.
+    // We need to ensure that the "core server build" is wrapped with an
+    // appropriate Lambda@Edge handler. We will utilise an internal asset
+    // template to create this wrapper within the "core server build" output
+    // directory.
+    // Ensure build directory exists
+    const buildPath = path.join(this.props.path, "build");
+    fs.mkdirSync(buildPath, { recursive: true });
+    // Copy the server lambda handler
+    fs.copyFileSync(
+      path.resolve(__dirname, `../support/remix-site-function/${wrapperFile}`),
+      path.join(buildPath, "server.js")
+    );
+    // Copy the Remix polyfil to the server build directory
+    //
+    // Note: We need to ensure that the polyfills are injected above other code that
+    // will depend on them. Importing them within the top of the lambda code
+    // doesn't appear to guarantee this, we therefore leverage ESBUild's
+    // `inject` option to ensure that the polyfills are injected at the top of
+    // the bundle.
+    const polyfillDest = path.join(buildPath, "polyfill.js");
+    fs.copyFileSync(
+      path.resolve(__dirname, "../support/remix-site-function/polyfill.js"),
+      polyfillDest
+    );
+    return {
+      handler: path.join(buildPath, "server.handler"),
+      esbuild: { inject: [polyfillDest] },
+    };
+  }
+  createFunctionForRegional() {
+    const {
+      runtime,
+      timeout,
+      memorySize,
+      permissions,
+      environment,
+      bind,
+      nodejs,
+      cdk,
+    } = this.props;
+    const { handler, esbuild } =
+      this.createServerLambdaBundle("regional-server.js");
+    return new SsrFunction(this, `ServerFunction`, {
+      description: "Server handler for Remix",
+      handler,
+      runtime,
+      memorySize,
+      timeout,
+      nodejs: {
+        format: "esm",
+        ...nodejs,
+        esbuild: {
+          ...esbuild,
+          ...nodejs?.esbuild,
+          inject: [...(nodejs?.esbuild?.inject || []), ...esbuild.inject],
+        },
+      },
+      bind,
+      environment,
+      permissions,
+      ...cdk?.server,
+    });
+  }
+  createFunctionForEdge() {
+    const {
+      runtime,
+      timeout,
+      memorySize,
+      bind,
+      permissions,
+      environment,
+      nodejs,
+    } = this.props;
+    const { handler, esbuild } =
+      this.createServerLambdaBundle("edge-server.js");
+    return new EdgeFunction(this, `Server`, {
+      scopeOverride: this,
+      handler,
+      runtime,
+      timeout,
+      memorySize,
+      bind,
+      environment,
+      permissions,
+      nodejs: {
+        format: "esm",
+        ...nodejs,
+        esbuild: {
+          ...esbuild,
+          ...nodejs?.esbuild,
+          inject: [...(nodejs?.esbuild?.inject || []), ...esbuild.inject],
+        },
+      },
+    });
+  }
+  getConstructMetadata() {
+    return {
+      type: "RemixSite",
+      ...this.getConstructMetadataBase(),
+    };
+  }
 }
diff --git a/constructs/SsrSite.js b/constructs/SsrSite.js
index b28b31e1cc037ecc94b643fbc244942bf666347b..bc925f7e39946deda948f5f748071350dfd5c008 100644
--- a/constructs/SsrSite.js
+++ b/constructs/SsrSite.js
@@ -6,13 +6,51 @@ import crypto from "crypto";
 import spawn from "cross-spawn";
 import { execSync } from "child_process";
 import { Construct } from "constructs";
-import { Fn, Token, Duration as CdkDuration, RemovalPolicy, CustomResource, } from "aws-cdk-lib/core";
-import { BlockPublicAccess, Bucket, } from "aws-cdk-lib/aws-s3";
-import { Role, Effect, Policy, PolicyStatement, AccountPrincipal, ServicePrincipal, CompositePrincipal, } from "aws-cdk-lib/aws-iam";
-import { Function as CdkFunction, Code, Runtime, FunctionUrlAuthType, } from "aws-cdk-lib/aws-lambda";
-import { HostedZone, ARecord, AaaaRecord, RecordTarget, } from "aws-cdk-lib/aws-route53";
+import {
+  Fn,
+  Token,
+  Duration as CdkDuration,
+  RemovalPolicy,
+  CustomResource,
+} from "aws-cdk-lib/core";
+import { BlockPublicAccess, Bucket } from "aws-cdk-lib/aws-s3";
+import {
+  Role,
+  Effect,
+  Policy,
+  PolicyStatement,
+  AccountPrincipal,
+  ServicePrincipal,
+  CompositePrincipal,
+} from "aws-cdk-lib/aws-iam";
+import {
+  Function as CdkFunction,
+  Code,
+  Runtime,
+  FunctionUrlAuthType,
+} from "aws-cdk-lib/aws-lambda";
+import {
+  HostedZone,
+  ARecord,
+  AaaaRecord,
+  RecordTarget,
+} from "aws-cdk-lib/aws-route53";
 import { Asset } from "aws-cdk-lib/aws-s3-assets";
-import { Distribution, ViewerProtocolPolicy, AllowedMethods, CachedMethods, LambdaEdgeEventType, CachePolicy, CacheQueryStringBehavior, CacheHeaderBehavior, CacheCookieBehavior, OriginRequestPolicy, Function as CfFunction, FunctionCode as CfFunctionCode, FunctionEventType as CfFunctionEventType, } from "aws-cdk-lib/aws-cloudfront";
+import {
+  Distribution,
+  ViewerProtocolPolicy,
+  AllowedMethods,
+  CachedMethods,
+  LambdaEdgeEventType,
+  CachePolicy,
+  CacheQueryStringBehavior,
+  CacheHeaderBehavior,
+  CacheCookieBehavior,
+  OriginRequestPolicy,
+  Function as CfFunction,
+  FunctionCode as CfFunctionCode,
+  FunctionEventType as CfFunctionEventType,
+} from "aws-cdk-lib/aws-cloudfront";
 import { AwsCliLayer } from "aws-cdk-lib/lambda-layer-awscli";
 import { S3Origin, HttpOrigin } from "aws-cdk-lib/aws-cloudfront-origins";
 import { CloudFrontTarget } from "aws-cdk-lib/aws-route53-targets";
@@ -22,13 +60,13 @@ import { createAppContext } from "./context.js";
 import { isCDKConstruct } from "./Construct.js";
 import { Secret } from "./Secret.js";
 import { SsrFunction } from "./SsrFunction.js";
-import { getBuildCmdEnvironment, } from "./BaseSite.js";
+import { getBuildCmdEnvironment } from "./BaseSite.js";
 import { useDeferredTasks } from "./deferred_task.js";
 import { HttpsRedirect } from "./cdk/website-redirect.js";
 import { DnsValidatedCertificate } from "./cdk/dns-validated-certificate.js";
 import { toCdkDuration } from "./util/duration.js";
 import { attachPermissionsToRole } from "./util/permission.js";
-import { getParameterPath, } from "./util/functionBinding.js";
+import { getParameterPath } from "./util/functionBinding.js";
 import { useProject } from "../project.js";
 const __dirname = url.fileURLToPath(new URL(".", import.meta.url));
 /**
@@ -43,870 +81,954 @@ const __dirname = url.fileURLToPath(new URL(".", import.meta.url));
  * ```
  */
 export class SsrSite extends Construct {
-    id;
-    props;
-    doNotDeploy;
-    buildConfig;
-    deferredTaskCallbacks = [];
-    serverLambdaForEdge;
-    serverLambdaForRegional;
-    serverLambdaForDev;
-    bucket;
-    cfFunction;
-    s3Origin;
-    distribution;
-    hostedZone;
-    certificate;
-    constructor(scope, id, props) {
-        super(scope, props?.cdk?.id || id);
-        const app = scope.node.root;
-        const stack = Stack.of(this);
-        this.id = id;
-        this.props = {
-            path: ".",
-            waitForInvalidation: false,
-            runtime: "nodejs18.x",
-            timeout: "10 seconds",
-            memorySize: "1024 MB",
-            ...props,
-        };
-        this.doNotDeploy =
-            !stack.isActive || (app.mode === "dev" && !this.props.dev?.deploy);
-        this.buildConfig = this.initBuildConfig();
-        this.validateSiteExists();
-        this.validateTimeout();
-        this.writeTypesFile();
-        useSites().add(id, this.constructor.name, this.props);
-        if (this.doNotDeploy) {
-            // @ts-ignore
-            this.cfFunction = this.bucket = this.s3Origin = this.distribution = null;
-            this.serverLambdaForDev = this.createFunctionForDev();
-            return;
-        }
-        // Create Bucket which will be utilised to contain the statics
-        this.bucket = this.createS3Bucket();
-        // Create Server functions
-        if (this.props.edge) {
-            this.serverLambdaForEdge = this.createFunctionForEdge();
-        }
-        else {
-            this.serverLambdaForRegional = this.createFunctionForRegional();
-        }
-        this.grantServerS3Permissions();
-        // Create Custom Domain
-        this.validateCustomDomainSettings();
-        this.hostedZone = this.lookupHostedZone();
-        this.certificate = this.createCertificate();
-        // Create CloudFront
-        this.validateCloudFrontDistributionSettings();
-        this.s3Origin = this.createCloudFrontS3Origin();
-        this.cfFunction = this.createCloudFrontFunction();
-        this.distribution = this.props.edge
-            ? this.createCloudFrontDistributionForEdge()
-            : this.createCloudFrontDistributionForRegional();
-        this.grantServerCloudFrontPermissions();
-        // Connect Custom Domain to CloudFront Distribution
-        this.createRoute53Records();
-        useDeferredTasks().add(async () => {
-            // Build app
-            this.buildApp();
-            // Build server functions
-            await this.serverLambdaForEdge?.build();
-            await this.serverLambdaForRegional?.build();
-            // Create S3 Deployment
-            const cliLayer = new AwsCliLayer(this, "AwsCliLayer");
-            const assets = this.createS3Assets();
-            const assetFileOptions = this.createS3AssetFileOptions();
-            const s3deployCR = this.createS3Deployment(cliLayer, assets, assetFileOptions);
-            this.distribution.node.addDependency(s3deployCR);
-            // Add static file behaviors
-            this.addStaticFileBehaviors();
-            // Invalidate CloudFront
-            this.createCloudFrontInvalidation();
-            for (const task of this.deferredTaskCallbacks) {
-                await task();
-            }
-        });
-    }
-    /////////////////////
-    // Public Properties
-    /////////////////////
-    /**
-     * The CloudFront URL of the website.
-     */
-    get url() {
-        if (this.doNotDeploy)
-            return this.props.dev?.url;
-        return `https://${this.distribution.distributionDomainName}`;
-    }
-    /**
-     * If the custom domain is enabled, this is the URL of the website with the
-     * custom domain.
-     */
-    get customDomainUrl() {
-        if (this.doNotDeploy)
-            return;
-        const { customDomain } = this.props;
-        if (!customDomain)
-            return;
-        if (typeof customDomain === "string") {
-            return `https://${customDomain}`;
-        }
-        else {
-            return `https://${customDomain.domainName}`;
-        }
-    }
-    /**
-     * The internally created CDK resources.
-     */
-    get cdk() {
-        if (this.doNotDeploy)
-            return;
-        return {
-            function: this.serverLambdaForEdge?.function ||
-                this.serverLambdaForRegional?.function,
-            bucket: this.bucket,
-            distribution: this.distribution,
-            hostedZone: this.hostedZone,
-            certificate: this.certificate,
-        };
-    }
-    /////////////////////
-    // Public Methods
-    /////////////////////
-    /**
-     * Attaches the given list of permissions to allow the server side
-     * rendering framework to access other AWS resources.
-     *
-     * @example
-     * ```js
-     * site.attachPermissions(["sns"]);
-     * ```
-     */
-    attachPermissions(permissions) {
-        const server = this.serverLambdaForEdge ||
-            this.serverLambdaForRegional ||
-            this.serverLambdaForDev;
-        attachPermissionsToRole(server?.role, permissions);
-    }
-    /** @internal */
-    getConstructMetadataBase() {
-        return {
-            data: {
-                mode: this.doNotDeploy
-                    ? "placeholder"
-                    : "deployed",
-                path: this.props.path,
-                customDomainUrl: this.customDomainUrl,
-                url: this.url,
-                edge: this.props.edge,
-                server: (this.serverLambdaForDev ||
-                    this.serverLambdaForRegional ||
-                    this.serverLambdaForEdge)?.functionArn,
-                secrets: (this.props.bind || [])
-                    .filter((c) => c instanceof Secret)
-                    .map((c) => c.name),
-            },
-        };
-    }
-    /** @internal */
-    getFunctionBinding() {
-        const app = this.node.root;
-        return {
-            clientPackage: "site",
-            variables: {
-                url: this.doNotDeploy
-                    ? {
-                        type: "plain",
-                        value: this.props.dev?.url ?? "localhost",
-                    }
-                    : {
-                        // Do not set real value b/c we don't want to make the Lambda function
-                        // depend on the Site. B/c often the site depends on the Api, causing
-                        // a CloudFormation circular dependency if the Api and the Site belong
-                        // to different stacks.
-                        type: "site_url",
-                        value: this.customDomainUrl || this.url,
-                    },
-            },
-            permissions: {
-                "ssm:GetParameters": [
-                    `arn:${Stack.of(this).partition}:ssm:${app.region}:${app.account}:parameter${getParameterPath(this, "url")}`,
-                ],
-            },
-        };
-    }
-    /////////////////////
-    // Build App
-    /////////////////////
-    initBuildConfig() {
-        return {
-            typesPath: ".",
-            serverBuildOutputFile: "placeholder",
-            clientBuildOutputDir: "placeholder",
-            clientBuildVersionedSubDir: "placeholder",
-        };
+  id;
+  props;
+  doNotDeploy;
+  buildConfig;
+  deferredTaskCallbacks = [];
+  serverLambdaForEdge;
+  serverLambdaForRegional;
+  serverLambdaForDev;
+  bucket;
+  cfFunction;
+  s3Origin;
+  distribution;
+  hostedZone;
+  certificate;
+  constructor(scope, id, props) {
+    super(scope, props?.cdk?.id || id);
+    const app = scope.node.root;
+    const stack = Stack.of(this);
+    this.id = id;
+    this.props = {
+      path: ".",
+      waitForInvalidation: false,
+      runtime: "nodejs18.x",
+      timeout: "10 seconds",
+      memorySize: "1024 MB",
+      ...props,
+    };
+    this.doNotDeploy =
+      !stack.isActive || (app.mode === "dev" && !this.props.dev?.deploy);
+    this.buildConfig = this.initBuildConfig();
+    this.validateSiteExists();
+    this.validateTimeout();
+    this.writeTypesFile();
+    useSites().add(id, this.constructor.name, this.props);
+    if (this.doNotDeploy) {
+      // @ts-ignore
+      this.cfFunction = this.bucket = this.s3Origin = this.distribution = null;
+      this.serverLambdaForDev = this.createFunctionForDev();
+      return;
     }
-    buildApp() {
-        const app = this.node.root;
-        if (!app.isRunningSSTTest()) {
-            this.runBuild();
-        }
-        this.validateBuildOutput();
+    // Create Bucket which will be utilised to contain the statics
+    this.bucket = this.createS3Bucket();
+    // Create Server functions
+    if (this.props.edge) {
+      this.serverLambdaForEdge = this.createFunctionForEdge();
+    } else {
+      this.serverLambdaForRegional = this.createFunctionForRegional();
     }
-    validateBuildOutput() {
-        const serverBuildFile = path.join(this.props.path, this.buildConfig.serverBuildOutputFile);
-        if (!fs.existsSync(serverBuildFile)) {
-            throw new Error(`No server build output found at "${serverBuildFile}"`);
-        }
+    this.grantServerS3Permissions();
+    // Create Custom Domain
+    this.validateCustomDomainSettings();
+    this.hostedZone = this.lookupHostedZone();
+    this.certificate = this.createCertificate();
+    // Create CloudFront
+    this.validateCloudFrontDistributionSettings();
+    this.s3Origin = this.createCloudFrontS3Origin();
+    this.cfFunction = this.createCloudFrontFunction();
+    this.distribution = this.props.edge
+      ? this.createCloudFrontDistributionForEdge()
+      : this.createCloudFrontDistributionForRegional();
+    this.grantServerCloudFrontPermissions();
+    // Connect Custom Domain to CloudFront Distribution
+    this.createRoute53Records();
+    useDeferredTasks().add(async () => {
+      // Build app
+      this.buildApp();
+      // Build server functions
+      await this.serverLambdaForEdge?.build();
+      await this.serverLambdaForRegional?.build();
+      // Create S3 Deployment
+      const cliLayer = new AwsCliLayer(this, "AwsCliLayer");
+      const assets = this.createS3Assets();
+      const assetFileOptions = this.createS3AssetFileOptions();
+      const s3deployCR = this.createS3Deployment(
+        cliLayer,
+        assets,
+        assetFileOptions
+      );
+      this.distribution.node.addDependency(s3deployCR);
+      // Add static file behaviors
+      this.addStaticFileBehaviors();
+      // Invalidate CloudFront
+      this.createCloudFrontInvalidation();
+      for (const task of this.deferredTaskCallbacks) {
+        await task();
+      }
+    });
+  }
+  /////////////////////
+  // Public Properties
+  /////////////////////
+  /**
+   * The CloudFront URL of the website.
+   */
+  get url() {
+    if (this.doNotDeploy) return this.props.dev?.url;
+    return `https://${this.distribution.distributionDomainName}`;
+  }
+  /**
+   * If the custom domain is enabled, this is the URL of the website with the
+   * custom domain.
+   */
+  get customDomainUrl() {
+    if (this.doNotDeploy) return;
+    const { customDomain } = this.props;
+    if (!customDomain) return;
+    if (typeof customDomain === "string") {
+      return `https://${customDomain}`;
+    } else {
+      return `https://${customDomain.domainName}`;
     }
-    runBuild() {
-        const { path: sitePath, buildCommand: rawBuildCommand, environment, } = this.props;
-        const defaultCommand = "npm run build";
-        const buildCommand = rawBuildCommand || defaultCommand;
-        if (buildCommand === defaultCommand) {
-            // Ensure that the site has a build script defined
-            if (!fs.existsSync(path.join(sitePath, "package.json"))) {
-                throw new Error(`No package.json found at "${sitePath}".`);
-            }
-            const packageJson = JSON.parse(fs.readFileSync(path.join(sitePath, "package.json")).toString());
-            if (!packageJson.scripts || !packageJson.scripts.build) {
-                throw new Error(`No "build" script found within package.json in "${sitePath}".`);
+  }
+  /**
+   * The internally created CDK resources.
+   */
+  get cdk() {
+    if (this.doNotDeploy) return;
+    return {
+      function:
+        this.serverLambdaForEdge?.function ||
+        this.serverLambdaForRegional?.function,
+      bucket: this.bucket,
+      distribution: this.distribution,
+      hostedZone: this.hostedZone,
+      certificate: this.certificate,
+    };
+  }
+  /////////////////////
+  // Public Methods
+  /////////////////////
+  /**
+   * Attaches the given list of permissions to allow the server side
+   * rendering framework to access other AWS resources.
+   *
+   * @example
+   * ```js
+   * site.attachPermissions(["sns"]);
+   * ```
+   */
+  attachPermissions(permissions) {
+    const server =
+      this.serverLambdaForEdge ||
+      this.serverLambdaForRegional ||
+      this.serverLambdaForDev;
+    attachPermissionsToRole(server?.role, permissions);
+  }
+  /** @internal */
+  getConstructMetadataBase() {
+    return {
+      data: {
+        mode: this.doNotDeploy ? "placeholder" : "deployed",
+        path: this.props.path,
+        customDomainUrl: this.customDomainUrl,
+        url: this.url,
+        edge: this.props.edge,
+        server: (
+          this.serverLambdaForDev ||
+          this.serverLambdaForRegional ||
+          this.serverLambdaForEdge
+        )?.functionArn,
+        secrets: (this.props.bind || [])
+          .filter((c) => c instanceof Secret)
+          .map((c) => c.name),
+      },
+    };
+  }
+  /** @internal */
+  getFunctionBinding() {
+    const app = this.node.root;
+    return {
+      clientPackage: "site",
+      variables: {
+        url: this.doNotDeploy
+          ? {
+              type: "plain",
+              value: this.props.dev?.url ?? "localhost",
             }
-        }
-        // Run build
-        Logger.debug(`Running "${buildCommand}" script`);
-        try {
-            execSync(buildCommand, {
-                cwd: sitePath,
-                stdio: "inherit",
-                env: {
-                    SST: "1",
-                    ...process.env,
-                    ...getBuildCmdEnvironment(environment),
-                },
-            });
-        }
-        catch (e) {
-            throw new Error(`There was a problem building the "${this.node.id}" site.`);
-        }
+          : {
+              // Do not set real value b/c we don't want to make the Lambda function
+              // depend on the Site. B/c often the site depends on the Api, causing
+              // a CloudFormation circular dependency if the Api and the Site belong
+              // to different stacks.
+              type: "site_url",
+              value: this.customDomainUrl || this.url,
+            },
+      },
+      permissions: {
+        "ssm:GetParameters": [
+          `arn:${Stack.of(this).partition}:ssm:${app.region}:${
+            app.account
+          }:parameter${getParameterPath(this, "url")}`,
+        ],
+      },
+    };
+  }
+  /////////////////////
+  // Build App
+  /////////////////////
+  initBuildConfig() {
+    return {
+      typesPath: ".",
+      serverBuildOutputFile: "placeholder",
+      clientBuildOutputDir: "placeholder",
+      clientBuildVersionedSubDir: "placeholder",
+    };
+  }
+  buildApp() {
+    const app = this.node.root;
+    if (!app.isRunningSSTTest()) {
+      this.runBuild();
     }
-    /////////////////////
-    // Bundle S3 Assets
-    /////////////////////
-    createS3Assets() {
-        // Create temp folder, clean up if exists
-        const zipOutDir = path.resolve(path.join(useProject().paths.artifacts, `Site-${this.node.id}-${this.node.addr}`));
-        fs.rmSync(zipOutDir, { recursive: true, force: true });
-        // Create zip files
-        const app = this.node.root;
-        const script = path.resolve(__dirname, "../support/base-site-archiver.mjs");
-        const fileSizeLimit = app.isRunningSSTTest()
-            ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment
-                // @ts-ignore: "sstTestFileSizeLimitOverride" not exposed in props
-                this.props.sstTestFileSizeLimitOverride || 200
-            : 200;
-        const result = spawn.sync("node", [
-            script,
-            Buffer.from(JSON.stringify([
-                {
-                    src: path.join(this.props.path, this.buildConfig.clientBuildOutputDir),
-                    tar: this.buildConfig.clientBuildS3KeyPrefix || "",
-                },
-                ...(this.buildConfig.prerenderedBuildOutputDir
-                    ? [
-                        {
-                            src: path.join(this.props.path, this.buildConfig.prerenderedBuildOutputDir),
-                            tar: this.buildConfig.prerenderedBuildS3KeyPrefix || "",
-                        },
-                    ]
-                    : []),
-            ])).toString("base64"),
-            zipOutDir,
-            `${fileSizeLimit}`,
-        ], {
-            stdio: "inherit",
-        });
-        if (result.status !== 0) {
-            throw new Error(`There was a problem generating the assets package.`);
-        }
-        // Create S3 Assets for each zip file
-        const assets = [];
-        for (let partId = 0;; partId++) {
-            const zipFilePath = path.join(zipOutDir, `part${partId}.zip`);
-            if (!fs.existsSync(zipFilePath)) {
-                break;
-            }
-            assets.push(new Asset(this, `Asset${partId}`, {
-                path: zipFilePath,
-            }));
-        }
-        return assets;
+    this.validateBuildOutput();
+  }
+  validateBuildOutput() {
+    const serverBuildFile = path.join(
+      this.props.path,
+      this.buildConfig.serverBuildOutputFile
+    );
+    if (!fs.existsSync(serverBuildFile)) {
+      throw new Error(`No server build output found at "${serverBuildFile}"`);
     }
-    createS3AssetFileOptions() {
-        if (this.props.fileOptions)
-            return this.props.fileOptions;
-        // Build file options
-        const fileOptions = [];
-        const clientPath = path.join(this.props.path, this.buildConfig.clientBuildOutputDir);
-        for (const item of fs.readdirSync(clientPath)) {
-            // Versioned files will be cached for 1 year (immutable) both at
-            // the CDN and browser level.
-            if (item === this.buildConfig.clientBuildVersionedSubDir) {
-                fileOptions.push({
-                    exclude: "*",
-                    include: path.posix.join(this.buildConfig.clientBuildS3KeyPrefix ?? "", this.buildConfig.clientBuildVersionedSubDir, "*"),
-                    cacheControl: "public,max-age=31536000,immutable",
-                });
-            }
-            // Un-versioned files will be cached for 1 year at the CDN level.
-            // But not at the browser level. CDN cache will be invalidated on deploy.
-            else {
-                const itemPath = path.join(clientPath, item);
-                fileOptions.push({
-                    exclude: "*",
-                    include: path.posix.join(this.buildConfig.clientBuildS3KeyPrefix ?? "", item, fs.statSync(itemPath).isDirectory() ? "*" : ""),
-                    cacheControl: "public,max-age=0,s-maxage=31536000,must-revalidate",
-                });
-            }
-        }
-        return fileOptions;
+  }
+  runBuild() {
+    const {
+      path: sitePath,
+      buildCommand: rawBuildCommand,
+      environment,
+    } = this.props;
+    const defaultCommand = "npm run build";
+    const buildCommand = rawBuildCommand || defaultCommand;
+    if (buildCommand === defaultCommand) {
+      // Ensure that the site has a build script defined
+      if (!fs.existsSync(path.join(sitePath, "package.json"))) {
+        throw new Error(`No package.json found at "${sitePath}".`);
+      }
+      const packageJson = JSON.parse(
+        fs.readFileSync(path.join(sitePath, "package.json")).toString()
+      );
+      if (!packageJson.scripts || !packageJson.scripts.build) {
+        throw new Error(
+          `No "build" script found within package.json in "${sitePath}".`
+        );
+      }
     }
-    createS3Bucket() {
-        const { cdk } = this.props;
-        // cdk.bucket is an imported construct
-        if (cdk?.bucket && isCDKConstruct(cdk?.bucket)) {
-            return cdk.bucket;
-        }
-        // cdk.bucket is a prop
-        return new Bucket(this, "S3Bucket", {
-            publicReadAccess: false,
-            blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
-            autoDeleteObjects: true,
-            removalPolicy: RemovalPolicy.DESTROY,
-            ...cdk?.bucket,
-        });
+    // Run build
+    Logger.debug(`Running "${buildCommand}" script`);
+    try {
+      execSync(buildCommand, {
+        cwd: sitePath,
+        stdio: "inherit",
+        env: {
+          SST: "1",
+          ...process.env,
+          ...getBuildCmdEnvironment(environment),
+        },
+      });
+    } catch (e) {
+      throw new Error(
+        `There was a problem building the "${this.node.id}" site.`
+      );
     }
-    createS3Deployment(cliLayer, assets, fileOptions) {
-        // Create a Lambda function that will be doing the uploading
-        const uploader = new CdkFunction(this, "S3Uploader", {
-            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
-            layers: [cliLayer],
-            runtime: Runtime.PYTHON_3_7,
-            handler: "s3-upload.handler",
-            timeout: CdkDuration.minutes(15),
-            memorySize: 1024,
-        });
-        this.bucket.grantReadWrite(uploader);
-        assets.forEach((asset) => asset.grantRead(uploader));
-        // Create the custom resource function
-        const handler = new CdkFunction(this, "S3Handler", {
-            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
-            layers: [cliLayer],
-            runtime: Runtime.PYTHON_3_7,
-            handler: "s3-handler.handler",
-            timeout: CdkDuration.minutes(15),
-            memorySize: 1024,
-            environment: {
-                UPLOADER_FUNCTION_NAME: uploader.functionName,
-            },
-        });
-        this.bucket.grantReadWrite(handler);
-        uploader.grantInvoke(handler);
-        // Create custom resource
-        return new CustomResource(this, "S3Deployment", {
-            serviceToken: handler.functionArn,
-            resourceType: "Custom::SSTBucketDeployment",
-            properties: {
-                Sources: assets.map((asset) => ({
-                    BucketName: asset.s3BucketName,
-                    ObjectKey: asset.s3ObjectKey,
-                })),
-                DestinationBucketName: this.bucket.bucketName,
-                FileOptions: (fileOptions || []).map(({ exclude, include, cacheControl, contentType }) => {
-                    if (typeof exclude === "string") {
-                        exclude = [exclude];
-                    }
-                    if (typeof include === "string") {
-                        include = [include];
-                    }
-                    return [
-                        ...exclude.map((per) => ["--exclude", per]),
-                        ...include.map((per) => ["--include", per]),
-                        ["--cache-control", cacheControl],
-                        contentType ? ["--content-type", contentType] : [],
-                    ].flat();
-                }),
-                ReplaceValues: this.getS3ContentReplaceValues(),
+  }
+  /////////////////////
+  // Bundle S3 Assets
+  /////////////////////
+  createS3Assets() {
+    // Create temp folder, clean up if exists
+    const zipOutDir = path.resolve(
+      path.join(
+        useProject().paths.artifacts,
+        `Site-${this.node.id}-${this.node.addr}`
+      )
+    );
+    fs.rmSync(zipOutDir, { recursive: true, force: true });
+    // Create zip files
+    const app = this.node.root;
+    const script = path.resolve(__dirname, "../support/base-site-archiver.mjs");
+    const fileSizeLimit = app.isRunningSSTTest()
+      ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+        // @ts-ignore: "sstTestFileSizeLimitOverride" not exposed in props
+        this.props.sstTestFileSizeLimitOverride || 200
+      : 200;
+    const result = spawn.sync(
+      "node",
+      [
+        script,
+        Buffer.from(
+          JSON.stringify([
+            {
+              src: path.join(
+                this.props.path,
+                this.buildConfig.clientBuildOutputDir
+              ),
+              tar: this.buildConfig.clientBuildS3KeyPrefix || "",
             },
-        });
+            ...(this.buildConfig.prerenderedBuildOutputDir
+              ? [
+                  {
+                    src: path.join(
+                      this.props.path,
+                      this.buildConfig.prerenderedBuildOutputDir
+                    ),
+                    tar: this.buildConfig.prerenderedBuildS3KeyPrefix || "",
+                  },
+                ]
+              : []),
+          ])
+        ).toString("base64"),
+        zipOutDir,
+        `${fileSizeLimit}`,
+      ],
+      {
+        stdio: "inherit",
+      }
+    );
+    if (result.status !== 0) {
+      throw new Error(`There was a problem generating the assets package.`);
     }
-    /////////////////////
-    // Bundle Lambda Server
-    /////////////////////
-    createFunctionForRegional() {
-        return {};
+    // Create S3 Assets for each zip file
+    const assets = [];
+    for (let partId = 0; ; partId++) {
+      const zipFilePath = path.join(zipOutDir, `part${partId}.zip`);
+      if (!fs.existsSync(zipFilePath)) {
+        break;
+      }
+      assets.push(
+        new Asset(this, `Asset${partId}`, {
+          path: zipFilePath,
+        })
+      );
     }
-    createFunctionForEdge() {
-        return {};
-    }
-    createFunctionForDev() {
-        const { runtime, timeout, memorySize, permissions, environment, bind } = this.props;
-        const app = this.node.root;
-        const role = new Role(this, "ServerFunctionRole", {
-            assumedBy: new CompositePrincipal(new AccountPrincipal(app.account), new ServicePrincipal("lambda.amazonaws.com")),
-            maxSessionDuration: CdkDuration.hours(12),
-        });
-        const ssrFn = new SsrFunction(this, `ServerFunction`, {
-            description: "Server handler placeholder",
-            bundle: path.join(__dirname, "../support/ssr-site-function-stub"),
-            handler: "index.handler",
-            runtime,
-            memorySize,
-            timeout,
-            role,
-            bind,
-            environment,
-            permissions,
-            // note: do not need to set vpc settings b/c this function is not being used
+    return assets;
+  }
+  createS3AssetFileOptions() {
+    if (this.props.fileOptions) return this.props.fileOptions;
+    // Build file options
+    const fileOptions = [];
+    const clientPath = path.join(
+      this.props.path,
+      this.buildConfig.clientBuildOutputDir
+    );
+    for (const item of fs.readdirSync(clientPath)) {
+      // Versioned files will be cached for 1 year (immutable) both at
+      // the CDN and browser level.
+      if (item === this.buildConfig.clientBuildVersionedSubDir) {
+        fileOptions.push({
+          exclude: "*",
+          include: path.posix.join(
+            this.buildConfig.clientBuildS3KeyPrefix ?? "",
+            this.buildConfig.clientBuildVersionedSubDir,
+            "*"
+          ),
+          cacheControl: "public,max-age=31536000,immutable",
         });
-        useDeferredTasks().add(async () => {
-            await ssrFn.build();
+      }
+      // Un-versioned files will be cached for 1 year at the CDN level.
+      // But not at the browser level. CDN cache will be invalidated on deploy.
+      else {
+        const itemPath = path.join(clientPath, item);
+        fileOptions.push({
+          exclude: "*",
+          include: path.posix.join(
+            this.buildConfig.clientBuildS3KeyPrefix ?? "",
+            item,
+            fs.statSync(itemPath).isDirectory() ? "*" : ""
+          ),
+          cacheControl: "public,max-age=0,s-maxage=31536000,must-revalidate",
         });
-        return ssrFn;
+      }
     }
-    grantServerS3Permissions() {
-        const server = this.serverLambdaForEdge || this.serverLambdaForRegional;
-        this.bucket.grantReadWrite(server.role);
-    }
-    grantServerCloudFrontPermissions() {
-        const stack = Stack.of(this);
-        const server = this.serverLambdaForEdge || this.serverLambdaForRegional;
-        const policy = new Policy(this, "ServerFunctionInvalidatorPolicy", {
-            statements: [
-                new PolicyStatement({
-                    actions: ["cloudfront:CreateInvalidation"],
-                    resources: [
-                        `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
-                    ],
-                }),
-            ],
-        });
-        server?.role?.attachInlinePolicy(policy);
+    return fileOptions;
+  }
+  createS3Bucket() {
+    const { cdk } = this.props;
+    // cdk.bucket is an imported construct
+    if (cdk?.bucket && isCDKConstruct(cdk?.bucket)) {
+      return cdk.bucket;
     }
-    /////////////////////
-    // CloudFront Distribution
-    /////////////////////
-    validateCloudFrontDistributionSettings() {
-        const { cdk } = this.props;
-        if (cdk?.distribution?.certificate) {
-            throw new Error(`Do not configure the "cfDistribution.certificate". Use the "customDomain" to configure the domain certificate.`);
-        }
-        if (cdk?.distribution?.domainNames) {
-            throw new Error(`Do not configure the "cfDistribution.domainNames". Use the "customDomain" to configure the domain name.`);
-        }
+    // cdk.bucket is a prop
+    return new Bucket(this, "S3Bucket", {
+      publicReadAccess: false,
+      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
+      autoDeleteObjects: true,
+      removalPolicy: RemovalPolicy.DESTROY,
+      ...cdk?.bucket,
+    });
+  }
+  createS3Deployment(cliLayer, assets, fileOptions) {
+    // Create a Lambda function that will be doing the uploading
+    const uploader = new CdkFunction(this, "S3Uploader", {
+      code: Code.fromAsset(
+        path.join(__dirname, "../support/base-site-custom-resource")
+      ),
+      layers: [cliLayer],
+      runtime: Runtime.PYTHON_3_7,
+      handler: "s3-upload.handler",
+      timeout: CdkDuration.minutes(15),
+      memorySize: 1024,
+    });
+    this.bucket.grantReadWrite(uploader);
+    assets.forEach((asset) => asset.grantRead(uploader));
+    // Create the custom resource function
+    const handler = new CdkFunction(this, "S3Handler", {
+      code: Code.fromAsset(
+        path.join(__dirname, "../support/base-site-custom-resource")
+      ),
+      layers: [cliLayer],
+      runtime: Runtime.PYTHON_3_7,
+      handler: "s3-handler.handler",
+      timeout: CdkDuration.minutes(15),
+      memorySize: 1024,
+      environment: {
+        UPLOADER_FUNCTION_NAME: uploader.functionName,
+      },
+    });
+    this.bucket.grantReadWrite(handler);
+    uploader.grantInvoke(handler);
+    // Create custom resource
+    return new CustomResource(this, "S3Deployment", {
+      serviceToken: handler.functionArn,
+      resourceType: "Custom::SSTBucketDeployment",
+      properties: {
+        Sources: assets.map((asset) => ({
+          BucketName: asset.s3BucketName,
+          ObjectKey: asset.s3ObjectKey,
+        })),
+        DestinationBucketName: this.bucket.bucketName,
+        FileOptions: (fileOptions || []).map(
+          ({ exclude, include, cacheControl, contentType }) => {
+            if (typeof exclude === "string") {
+              exclude = [exclude];
+            }
+            if (typeof include === "string") {
+              include = [include];
+            }
+            return [
+              ...exclude.map((per) => ["--exclude", per]),
+              ...include.map((per) => ["--include", per]),
+              ["--cache-control", cacheControl],
+              contentType ? ["--content-type", contentType] : [],
+            ].flat();
+          }
+        ),
+        ReplaceValues: this.getS3ContentReplaceValues(),
+      },
+    });
+  }
+  /////////////////////
+  // Bundle Lambda Server
+  /////////////////////
+  createFunctionForRegional() {
+    return {};
+  }
+  createFunctionForEdge() {
+    return {};
+  }
+  createFunctionForDev() {
+    const { runtime, timeout, memorySize, permissions, environment, bind } =
+      this.props;
+    const app = this.node.root;
+    const role = new Role(this, "ServerFunctionRole", {
+      assumedBy: new CompositePrincipal(
+        new AccountPrincipal(app.account),
+        new ServicePrincipal("lambda.amazonaws.com")
+      ),
+      maxSessionDuration: CdkDuration.hours(12),
+    });
+    const ssrFn = new SsrFunction(this, `ServerFunction`, {
+      description: "Server handler placeholder",
+      bundle: path.join(__dirname, "../support/ssr-site-function-stub"),
+      handler: "index.handler",
+      runtime,
+      memorySize,
+      timeout,
+      role,
+      bind,
+      environment,
+      permissions,
+      // note: do not need to set vpc settings b/c this function is not being used
+    });
+    useDeferredTasks().add(async () => {
+      await ssrFn.build();
+    });
+    return ssrFn;
+  }
+  grantServerS3Permissions() {
+    const server = this.serverLambdaForEdge || this.serverLambdaForRegional;
+    this.bucket.grantReadWrite(server.role);
+  }
+  grantServerCloudFrontPermissions() {
+    const stack = Stack.of(this);
+    const server = this.serverLambdaForEdge || this.serverLambdaForRegional;
+    const policy = new Policy(this, "ServerFunctionInvalidatorPolicy", {
+      statements: [
+        new PolicyStatement({
+          actions: ["cloudfront:CreateInvalidation"],
+          resources: [
+            `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
+          ],
+        }),
+      ],
+    });
+    server?.role?.attachInlinePolicy(policy);
+  }
+  /////////////////////
+  // CloudFront Distribution
+  /////////////////////
+  validateCloudFrontDistributionSettings() {
+    const { cdk } = this.props;
+    if (cdk?.distribution?.certificate) {
+      throw new Error(
+        `Do not configure the "cfDistribution.certificate". Use the "customDomain" to configure the domain certificate.`
+      );
     }
-    createCloudFrontS3Origin() {
-        return new S3Origin(this.bucket, {
-            originPath: "/" + (this.buildConfig.clientBuildS3KeyPrefix ?? ""),
-        });
+    if (cdk?.distribution?.domainNames) {
+      throw new Error(
+        `Do not configure the "cfDistribution.domainNames". Use the "customDomain" to configure the domain name.`
+      );
     }
-    createCloudFrontFunction() {
-        return new CfFunction(this, "CloudFrontFunction", {
-            code: CfFunctionCode.fromInline(`
+  }
+  createCloudFrontS3Origin() {
+    return new S3Origin(this.bucket, {
+      originPath: "/" + (this.buildConfig.clientBuildS3KeyPrefix ?? ""),
+    });
+  }
+  createCloudFrontFunction() {
+    return new CfFunction(this, "CloudFrontFunction", {
+      code: CfFunctionCode.fromInline(`
 function handler(event) {
   var request = event.request;
   request.headers["x-forwarded-host"] = request.headers.host;
   ${this.buildConfig.serverCFFunctionInjection || ""}
   return request;
 }`),
-        });
-    }
-    createCloudFrontDistributionForRegional() {
-        const { cdk } = this.props;
-        const cfDistributionProps = cdk?.distribution || {};
-        const cachePolicy = cdk?.serverCachePolicy ?? this.buildServerCachePolicy();
-        return new Distribution(this, "Distribution", {
-            // these values can be overwritten by cfDistributionProps
-            defaultRootObject: "",
-            // Override props.
-            ...cfDistributionProps,
-            // these values can NOT be overwritten by cfDistributionProps
-            domainNames: this.buildDistributionDomainNames(),
-            certificate: this.certificate,
-            defaultBehavior: this.buildDefaultBehaviorForRegional(cachePolicy),
-            additionalBehaviors: {
-                ...(cfDistributionProps.additionalBehaviors || {}),
-            },
-        });
-    }
-    createCloudFrontDistributionForEdge() {
-        const { cdk } = this.props;
-        const cfDistributionProps = cdk?.distribution || {};
-        const cachePolicy = cdk?.serverCachePolicy ?? this.buildServerCachePolicy();
-        return new Distribution(this, "Distribution", {
-            // these values can be overwritten by cfDistributionProps
-            defaultRootObject: "",
-            // Override props.
-            ...cfDistributionProps,
-            // these values can NOT be overwritten by cfDistributionProps
-            domainNames: this.buildDistributionDomainNames(),
-            certificate: this.certificate,
-            defaultBehavior: this.buildDefaultBehaviorForEdge(cachePolicy),
-            additionalBehaviors: {
-                ...(cfDistributionProps.additionalBehaviors || {}),
-            },
-        });
+    });
+  }
+  createCloudFrontDistributionForRegional() {
+    const { cdk } = this.props;
+    const cfDistributionProps = cdk?.distribution || {};
+    const cachePolicy = cdk?.serverCachePolicy ?? this.buildServerCachePolicy();
+    return new Distribution(this, "Distribution", {
+      // these values can be overwritten by cfDistributionProps
+      defaultRootObject: "",
+      // Override props.
+      ...cfDistributionProps,
+      // these values can NOT be overwritten by cfDistributionProps
+      domainNames: this.buildDistributionDomainNames(),
+      certificate: this.certificate,
+      defaultBehavior: this.buildDefaultBehaviorForRegional(cachePolicy),
+      additionalBehaviors: {
+        ...(cfDistributionProps.additionalBehaviors || {}),
+      },
+    });
+  }
+  createCloudFrontDistributionForEdge() {
+    const { cdk } = this.props;
+    const cfDistributionProps = cdk?.distribution || {};
+    const cachePolicy = cdk?.serverCachePolicy ?? this.buildServerCachePolicy();
+    return new Distribution(this, "Distribution", {
+      // these values can be overwritten by cfDistributionProps
+      defaultRootObject: "",
+      // Override props.
+      ...cfDistributionProps,
+      // these values can NOT be overwritten by cfDistributionProps
+      domainNames: this.buildDistributionDomainNames(),
+      certificate: this.certificate,
+      defaultBehavior: this.buildDefaultBehaviorForEdge(cachePolicy),
+      additionalBehaviors: {
+        ...(cfDistributionProps.additionalBehaviors || {}),
+      },
+    });
+  }
+  buildDistributionDomainNames() {
+    const { customDomain } = this.props;
+    const domainNames = [];
+    if (!customDomain) {
+      // no domain
+    } else if (typeof customDomain === "string") {
+      domainNames.push(customDomain);
+    } else {
+      domainNames.push(customDomain.domainName);
+      if (customDomain.alternateNames) {
+        if (!customDomain.cdk?.certificate)
+          throw new Error(
+            "Certificates for alternate domains cannot be automatically created. Please specify certificate to use"
+          );
+        domainNames.push(...customDomain.alternateNames);
+      }
     }
-    buildDistributionDomainNames() {
-        const { customDomain } = this.props;
-        const domainNames = [];
-        if (!customDomain) {
-            // no domain
-        }
-        else if (typeof customDomain === "string") {
-            domainNames.push(customDomain);
-        }
-        else {
-            domainNames.push(customDomain.domainName);
-            if (customDomain.alternateNames) {
-                if (!customDomain.cdk?.certificate)
-                    throw new Error("Certificates for alternate domains cannot be automatically created. Please specify certificate to use");
-                domainNames.push(...customDomain.alternateNames);
-            }
-        }
-        return domainNames;
+    return domainNames;
+  }
+  buildDefaultBehaviorForRegional(cachePolicy) {
+    const { timeout, cdk } = this.props;
+    const cfDistributionProps = cdk?.distribution || {};
+    const fnUrl = this.serverLambdaForRegional.addFunctionUrl({
+      authType: FunctionUrlAuthType.NONE,
+    });
+    // Invoke mode is not available in L2 construct yet
+    const cfnUrl = fnUrl.node.defaultChild;
+    cfnUrl.invokeMode = "RESPONSE_STREAM";
+    return {
+      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
+      origin: new HttpOrigin(Fn.parseDomainName(fnUrl.url), {
+        readTimeout:
+          typeof timeout === "string"
+            ? toCdkDuration(timeout)
+            : CdkDuration.seconds(timeout),
+      }),
+      allowedMethods: AllowedMethods.ALLOW_ALL,
+      cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
+      compress: true,
+      cachePolicy,
+      responseHeadersPolicy: cdk?.responseHeadersPolicy,
+      originRequestPolicy: this.buildServerOriginRequestPolicy(),
+      ...(cfDistributionProps.defaultBehavior || {}),
+      functionAssociations: [
+        ...this.buildBehaviorFunctionAssociations(),
+        ...(cfDistributionProps.defaultBehavior?.functionAssociations || []),
+      ],
+    };
+  }
+  buildDefaultBehaviorForEdge(cachePolicy) {
+    const { cdk } = this.props;
+    const cfDistributionProps = cdk?.distribution || {};
+    return {
+      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
+      origin: this.s3Origin,
+      allowedMethods: AllowedMethods.ALLOW_ALL,
+      cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
+      compress: true,
+      cachePolicy,
+      responseHeadersPolicy: cdk?.responseHeadersPolicy,
+      originRequestPolicy: this.buildServerOriginRequestPolicy(),
+      ...(cfDistributionProps.defaultBehavior || {}),
+      functionAssociations: [
+        ...this.buildBehaviorFunctionAssociations(),
+        ...(cfDistributionProps.defaultBehavior?.functionAssociations || []),
+      ],
+      edgeLambdas: [
+        {
+          includeBody: true,
+          eventType: LambdaEdgeEventType.ORIGIN_REQUEST,
+          functionVersion: this.serverLambdaForEdge.currentVersion,
+        },
+        ...(cfDistributionProps.defaultBehavior?.edgeLambdas || []),
+      ],
+    };
+  }
+  buildBehaviorFunctionAssociations() {
+    return [
+      {
+        eventType: CfFunctionEventType.VIEWER_REQUEST,
+        function: this.cfFunction,
+      },
+    ];
+  }
+  addStaticFileBehaviors() {
+    const { cdk } = this.props;
+    // Create a template for statics behaviours
+    const publicDir = path.join(
+      this.props.path,
+      this.buildConfig.clientBuildOutputDir
+    );
+    for (const item of fs.readdirSync(publicDir)) {
+      const isDir = fs.statSync(path.join(publicDir, item)).isDirectory();
+      this.distribution.addBehavior(isDir ? `${item}/*` : item, this.s3Origin, {
+        viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
+        allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
+        cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
+        compress: true,
+        cachePolicy: CachePolicy.CACHING_OPTIMIZED,
+        responseHeadersPolicy: cdk?.responseHeadersPolicy,
+      });
     }
-    buildDefaultBehaviorForRegional(cachePolicy) {
-        const { timeout, cdk } = this.props;
-        const cfDistributionProps = cdk?.distribution || {};
-        const fnUrl = this.serverLambdaForRegional.addFunctionUrl({
-            authType: FunctionUrlAuthType.NONE,
-        });
-        return {
-            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
-            origin: new HttpOrigin(Fn.parseDomainName(fnUrl.url), {
-                readTimeout: typeof timeout === "string"
-                    ? toCdkDuration(timeout)
-                    : CdkDuration.seconds(timeout),
-            }),
-            allowedMethods: AllowedMethods.ALLOW_ALL,
-            cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
-            compress: true,
-            cachePolicy,
-            responseHeadersPolicy: cdk?.responseHeadersPolicy,
-            originRequestPolicy: this.buildServerOriginRequestPolicy(),
-            ...(cfDistributionProps.defaultBehavior || {}),
-            functionAssociations: [
-                ...this.buildBehaviorFunctionAssociations(),
-                ...(cfDistributionProps.defaultBehavior?.functionAssociations || []),
-            ],
-        };
+  }
+  buildServerCachePolicy(allowedHeaders) {
+    return new CachePolicy(this, "ServerCache", {
+      queryStringBehavior: CacheQueryStringBehavior.all(),
+      headerBehavior:
+        allowedHeaders && allowedHeaders.length > 0
+          ? CacheHeaderBehavior.allowList(...allowedHeaders)
+          : CacheHeaderBehavior.none(),
+      cookieBehavior: CacheCookieBehavior.none(),
+      defaultTtl: CdkDuration.days(0),
+      maxTtl: CdkDuration.days(365),
+      minTtl: CdkDuration.days(0),
+      enableAcceptEncodingBrotli: true,
+      enableAcceptEncodingGzip: true,
+      comment: "SST server response cache policy",
+    });
+  }
+  buildServerOriginRequestPolicy() {
+    // CloudFront's Managed-AllViewerExceptHostHeader policy
+    return OriginRequestPolicy.fromOriginRequestPolicyId(
+      this,
+      "ServerOriginRequestPolicy",
+      "b689b0a8-53d0-40ab-baf2-68738e2966ac"
+    );
+  }
+  createCloudFrontInvalidation() {
+    const stack = Stack.of(this);
+    const policy = new Policy(this, "CloudFrontInvalidatorPolicy", {
+      statements: [
+        new PolicyStatement({
+          effect: Effect.ALLOW,
+          actions: [
+            "cloudfront:GetInvalidation",
+            "cloudfront:CreateInvalidation",
+          ],
+          resources: [
+            `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
+          ],
+        }),
+      ],
+    });
+    stack.customResourceHandler.role?.attachInlinePolicy(policy);
+    const resource = new CustomResource(this, "CloudFrontInvalidator", {
+      serviceToken: stack.customResourceHandler.functionArn,
+      resourceType: "Custom::CloudFrontInvalidator",
+      properties: {
+        buildId: this.generateBuildId(),
+        distributionId: this.distribution.distributionId,
+        paths: ["/*"],
+        waitForInvalidation: this.props.waitForInvalidation,
+      },
+    });
+    resource.node.addDependency(policy);
+    return resource;
+  }
+  /////////////////////
+  // Custom Domain
+  /////////////////////
+  validateCustomDomainSettings() {
+    const { customDomain } = this.props;
+    if (!customDomain) {
+      return;
     }
-    buildDefaultBehaviorForEdge(cachePolicy) {
-        const { cdk } = this.props;
-        const cfDistributionProps = cdk?.distribution || {};
-        return {
-            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
-            origin: this.s3Origin,
-            allowedMethods: AllowedMethods.ALLOW_ALL,
-            cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
-            compress: true,
-            cachePolicy,
-            responseHeadersPolicy: cdk?.responseHeadersPolicy,
-            originRequestPolicy: this.buildServerOriginRequestPolicy(),
-            ...(cfDistributionProps.defaultBehavior || {}),
-            functionAssociations: [
-                ...this.buildBehaviorFunctionAssociations(),
-                ...(cfDistributionProps.defaultBehavior?.functionAssociations || []),
-            ],
-            edgeLambdas: [
-                {
-                    includeBody: true,
-                    eventType: LambdaEdgeEventType.ORIGIN_REQUEST,
-                    functionVersion: this.serverLambdaForEdge.currentVersion,
-                },
-                ...(cfDistributionProps.defaultBehavior?.edgeLambdas || []),
-            ],
-        };
+    if (typeof customDomain === "string") {
+      return;
     }
-    buildBehaviorFunctionAssociations() {
-        return [
-            {
-                eventType: CfFunctionEventType.VIEWER_REQUEST,
-                function: this.cfFunction,
-            },
-        ];
+    if (customDomain.isExternalDomain === true) {
+      if (!customDomain.cdk?.certificate) {
+        throw new Error(
+          `A valid certificate is required when "isExternalDomain" is set to "true".`
+        );
+      }
+      if (customDomain.domainAlias) {
+        throw new Error(
+          `Domain alias is only supported for domains hosted on Amazon Route 53. Do not set the "customDomain.domainAlias" when "isExternalDomain" is enabled.`
+        );
+      }
+      if (customDomain.hostedZone) {
+        throw new Error(
+          `Hosted zones can only be configured for domains hosted on Amazon Route 53. Do not set the "customDomain.hostedZone" when "isExternalDomain" is enabled.`
+        );
+      }
     }
-    addStaticFileBehaviors() {
-        const { cdk } = this.props;
-        // Create a template for statics behaviours
-        const publicDir = path.join(this.props.path, this.buildConfig.clientBuildOutputDir);
-        for (const item of fs.readdirSync(publicDir)) {
-            const isDir = fs.statSync(path.join(publicDir, item)).isDirectory();
-            this.distribution.addBehavior(isDir ? `${item}/*` : item, this.s3Origin, {
-                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
-                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
-                cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
-                compress: true,
-                cachePolicy: CachePolicy.CACHING_OPTIMIZED,
-                responseHeadersPolicy: cdk?.responseHeadersPolicy,
-            });
-        }
+  }
+  lookupHostedZone() {
+    const { customDomain } = this.props;
+    // Skip if customDomain is not configured
+    if (!customDomain) {
+      return;
     }
-    buildServerCachePolicy(allowedHeaders) {
-        return new CachePolicy(this, "ServerCache", {
-            queryStringBehavior: CacheQueryStringBehavior.all(),
-            headerBehavior: allowedHeaders && allowedHeaders.length > 0
-                ? CacheHeaderBehavior.allowList(...allowedHeaders)
-                : CacheHeaderBehavior.none(),
-            cookieBehavior: CacheCookieBehavior.none(),
-            defaultTtl: CdkDuration.days(0),
-            maxTtl: CdkDuration.days(365),
-            minTtl: CdkDuration.days(0),
-            enableAcceptEncodingBrotli: true,
-            enableAcceptEncodingGzip: true,
-            comment: "SST server response cache policy",
-        });
+    let hostedZone;
+    if (typeof customDomain === "string") {
+      hostedZone = HostedZone.fromLookup(this, "HostedZone", {
+        domainName: customDomain,
+      });
+    } else if (customDomain.cdk?.hostedZone) {
+      hostedZone = customDomain.cdk.hostedZone;
+    } else if (typeof customDomain.hostedZone === "string") {
+      hostedZone = HostedZone.fromLookup(this, "HostedZone", {
+        domainName: customDomain.hostedZone,
+      });
+    } else if (typeof customDomain.domainName === "string") {
+      // Skip if domain is not a Route53 domain
+      if (customDomain.isExternalDomain === true) {
+        return;
+      }
+      hostedZone = HostedZone.fromLookup(this, "HostedZone", {
+        domainName: customDomain.domainName,
+      });
+    } else {
+      hostedZone = customDomain.hostedZone;
     }
-    buildServerOriginRequestPolicy() {
-        // CloudFront's Managed-AllViewerExceptHostHeader policy
-        return OriginRequestPolicy.fromOriginRequestPolicyId(this, "ServerOriginRequestPolicy", "b689b0a8-53d0-40ab-baf2-68738e2966ac");
+    return hostedZone;
+  }
+  createCertificate() {
+    const { customDomain } = this.props;
+    if (!customDomain) {
+      return;
     }
-    createCloudFrontInvalidation() {
-        const stack = Stack.of(this);
-        const policy = new Policy(this, "CloudFrontInvalidatorPolicy", {
-            statements: [
-                new PolicyStatement({
-                    effect: Effect.ALLOW,
-                    actions: [
-                        "cloudfront:GetInvalidation",
-                        "cloudfront:CreateInvalidation",
-                    ],
-                    resources: [
-                        `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
-                    ],
-                }),
-            ],
+    let acmCertificate;
+    // HostedZone is set for Route 53 domains
+    if (this.hostedZone) {
+      if (typeof customDomain === "string") {
+        acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
+          domainName: customDomain,
+          hostedZone: this.hostedZone,
+          region: "us-east-1",
         });
-        stack.customResourceHandler.role?.attachInlinePolicy(policy);
-        const resource = new CustomResource(this, "CloudFrontInvalidator", {
-            serviceToken: stack.customResourceHandler.functionArn,
-            resourceType: "Custom::CloudFrontInvalidator",
-            properties: {
-                buildId: this.generateBuildId(),
-                distributionId: this.distribution.distributionId,
-                paths: ["/*"],
-                waitForInvalidation: this.props.waitForInvalidation,
-            },
+      } else if (customDomain.cdk?.certificate) {
+        acmCertificate = customDomain.cdk.certificate;
+      } else {
+        acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
+          domainName: customDomain.domainName,
+          hostedZone: this.hostedZone,
+          region: "us-east-1",
         });
-        resource.node.addDependency(policy);
-        return resource;
+      }
     }
-    /////////////////////
-    // Custom Domain
-    /////////////////////
-    validateCustomDomainSettings() {
-        const { customDomain } = this.props;
-        if (!customDomain) {
-            return;
-        }
-        if (typeof customDomain === "string") {
-            return;
-        }
-        if (customDomain.isExternalDomain === true) {
-            if (!customDomain.cdk?.certificate) {
-                throw new Error(`A valid certificate is required when "isExternalDomain" is set to "true".`);
-            }
-            if (customDomain.domainAlias) {
-                throw new Error(`Domain alias is only supported for domains hosted on Amazon Route 53. Do not set the "customDomain.domainAlias" when "isExternalDomain" is enabled.`);
-            }
-            if (customDomain.hostedZone) {
-                throw new Error(`Hosted zones can only be configured for domains hosted on Amazon Route 53. Do not set the "customDomain.hostedZone" when "isExternalDomain" is enabled.`);
-            }
-        }
+    // HostedZone is NOT set for non-Route 53 domains
+    else {
+      if (typeof customDomain !== "string") {
+        acmCertificate = customDomain.cdk?.certificate;
+      }
     }
-    lookupHostedZone() {
-        const { customDomain } = this.props;
-        // Skip if customDomain is not configured
-        if (!customDomain) {
-            return;
-        }
-        let hostedZone;
-        if (typeof customDomain === "string") {
-            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
-                domainName: customDomain,
-            });
-        }
-        else if (customDomain.cdk?.hostedZone) {
-            hostedZone = customDomain.cdk.hostedZone;
-        }
-        else if (typeof customDomain.hostedZone === "string") {
-            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
-                domainName: customDomain.hostedZone,
-            });
-        }
-        else if (typeof customDomain.domainName === "string") {
-            // Skip if domain is not a Route53 domain
-            if (customDomain.isExternalDomain === true) {
-                return;
-            }
-            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
-                domainName: customDomain.domainName,
-            });
-        }
-        else {
-            hostedZone = customDomain.hostedZone;
-        }
-        return hostedZone;
+    return acmCertificate;
+  }
+  createRoute53Records() {
+    const { customDomain } = this.props;
+    if (!customDomain || !this.hostedZone) {
+      return;
     }
-    createCertificate() {
-        const { customDomain } = this.props;
-        if (!customDomain) {
-            return;
-        }
-        let acmCertificate;
-        // HostedZone is set for Route 53 domains
-        if (this.hostedZone) {
-            if (typeof customDomain === "string") {
-                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
-                    domainName: customDomain,
-                    hostedZone: this.hostedZone,
-                    region: "us-east-1",
-                });
-            }
-            else if (customDomain.cdk?.certificate) {
-                acmCertificate = customDomain.cdk.certificate;
-            }
-            else {
-                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
-                    domainName: customDomain.domainName,
-                    hostedZone: this.hostedZone,
-                    region: "us-east-1",
-                });
-            }
-        }
-        // HostedZone is NOT set for non-Route 53 domains
-        else {
-            if (typeof customDomain !== "string") {
-                acmCertificate = customDomain.cdk?.certificate;
-            }
-        }
-        return acmCertificate;
+    let recordName;
+    let domainAlias;
+    if (typeof customDomain === "string") {
+      recordName = customDomain;
+    } else {
+      recordName = customDomain.domainName;
+      domainAlias = customDomain.domainAlias;
     }
-    createRoute53Records() {
-        const { customDomain } = this.props;
-        if (!customDomain || !this.hostedZone) {
-            return;
-        }
-        let recordName;
-        let domainAlias;
-        if (typeof customDomain === "string") {
-            recordName = customDomain;
-        }
-        else {
-            recordName = customDomain.domainName;
-            domainAlias = customDomain.domainAlias;
-        }
-        // Create DNS record
-        const recordProps = {
-            recordName,
-            zone: this.hostedZone,
-            target: RecordTarget.fromAlias(new CloudFrontTarget(this.distribution)),
-        };
-        new ARecord(this, "AliasRecord", recordProps);
-        new AaaaRecord(this, "AliasRecordAAAA", recordProps);
-        // Create Alias redirect record
-        if (domainAlias) {
-            new HttpsRedirect(this, "Redirect", {
-                zone: this.hostedZone,
-                recordNames: [domainAlias],
-                targetDomain: recordName,
-            });
-        }
-    }
-    /////////////////////
-    // Helper Functions
-    /////////////////////
-    getS3ContentReplaceValues() {
-        const replaceValues = [];
-        Object.entries(this.props.environment || {})
-            .filter(([, value]) => Token.isUnresolved(value))
-            .forEach(([key, value]) => {
-            const token = `{{ ${key} }}`;
-            replaceValues.push({
-                files: "**/*.html",
-                search: token,
-                replace: value,
-            }, {
-                files: "**/*.js",
-                search: token,
-                replace: value,
-            }, {
-                files: "**/*.json",
-                search: token,
-                replace: value,
-            });
-        });
-        return replaceValues;
-    }
-    validateSiteExists() {
-        const { path: sitePath } = this.props;
-        if (!fs.existsSync(sitePath)) {
-            throw new Error(`No site found at "${path.resolve(sitePath)}"`);
-        }
+    // Create DNS record
+    const recordProps = {
+      recordName,
+      zone: this.hostedZone,
+      target: RecordTarget.fromAlias(new CloudFrontTarget(this.distribution)),
+    };
+    new ARecord(this, "AliasRecord", recordProps);
+    new AaaaRecord(this, "AliasRecordAAAA", recordProps);
+    // Create Alias redirect record
+    if (domainAlias) {
+      new HttpsRedirect(this, "Redirect", {
+        zone: this.hostedZone,
+        recordNames: [domainAlias],
+        targetDomain: recordName,
+      });
     }
-    validateTimeout() {
-        const { edge, timeout } = this.props;
-        const num = typeof timeout === "number"
-            ? timeout
-            : toCdkDuration(timeout).toSeconds();
-        const limit = edge ? 30 : 180;
-        if (num > limit) {
-            throw new Error(edge
-                ? `Timeout must be less than or equal to 30 seconds when the "edge" flag is enabled.`
-                : `Timeout must be less than or equal to 180 seconds.`);
-        }
+  }
+  /////////////////////
+  // Helper Functions
+  /////////////////////
+  getS3ContentReplaceValues() {
+    const replaceValues = [];
+    Object.entries(this.props.environment || {})
+      .filter(([, value]) => Token.isUnresolved(value))
+      .forEach(([key, value]) => {
+        const token = `{{ ${key} }}`;
+        replaceValues.push(
+          {
+            files: "**/*.html",
+            search: token,
+            replace: value,
+          },
+          {
+            files: "**/*.js",
+            search: token,
+            replace: value,
+          },
+          {
+            files: "**/*.json",
+            search: token,
+            replace: value,
+          }
+        );
+      });
+    return replaceValues;
+  }
+  validateSiteExists() {
+    const { path: sitePath } = this.props;
+    if (!fs.existsSync(sitePath)) {
+      throw new Error(`No site found at "${path.resolve(sitePath)}"`);
     }
-    writeTypesFile() {
-        const typesPath = path.resolve(this.props.path, this.buildConfig.typesPath, "sst-env.d.ts");
-        // Do not override the types file if it already exists
-        if (fs.existsSync(typesPath))
-            return;
-        const relPathToSstTypesFile = path.join(path.relative(path.dirname(typesPath), useProject().paths.root), ".sst/types/index.ts");
-        fs.writeFileSync(typesPath, `/// <reference path="${relPathToSstTypesFile}" />`);
+  }
+  validateTimeout() {
+    const { edge, timeout } = this.props;
+    const num =
+      typeof timeout === "number"
+        ? timeout
+        : toCdkDuration(timeout).toSeconds();
+    const limit = edge ? 30 : 180;
+    if (num > limit) {
+      throw new Error(
+        edge
+          ? `Timeout must be less than or equal to 30 seconds when the "edge" flag is enabled.`
+          : `Timeout must be less than or equal to 180 seconds.`
+      );
     }
-    generateBuildId() {
-        // We will generate a hash based on the contents of the "public" folder
-        // which will be used to indicate if we need to invalidate our CloudFront
-        // cache.
-        // The below options are needed to support following symlinks when building zip files:
-        // - nodir: This will prevent symlinks themselves from being copied into the zip.
-        // - follow: This will follow symlinks and copy the files within.
-        const globOptions = {
-            dot: true,
-            nodir: true,
-            follow: true,
-            cwd: path.resolve(this.props.path, this.buildConfig.clientBuildOutputDir),
-        };
-        const files = glob.sync("**", globOptions);
-        const hash = crypto.createHash("sha1");
-        for (const file of files) {
-            hash.update(file);
-        }
-        const buildId = hash.digest("hex");
-        Logger.debug(`Generated build ID ${buildId}`);
-        return buildId;
+  }
+  writeTypesFile() {
+    const typesPath = path.resolve(
+      this.props.path,
+      this.buildConfig.typesPath,
+      "sst-env.d.ts"
+    );
+    // Do not override the types file if it already exists
+    if (fs.existsSync(typesPath)) return;
+    const relPathToSstTypesFile = path.join(
+      path.relative(path.dirname(typesPath), useProject().paths.root),
+      ".sst/types/index.ts"
+    );
+    fs.writeFileSync(
+      typesPath,
+      `/// <reference path="${relPathToSstTypesFile}" />`
+    );
+  }
+  generateBuildId() {
+    // We will generate a hash based on the contents of the "public" folder
+    // which will be used to indicate if we need to invalidate our CloudFront
+    // cache.
+    // The below options are needed to support following symlinks when building zip files:
+    // - nodir: This will prevent symlinks themselves from being copied into the zip.
+    // - follow: This will follow symlinks and copy the files within.
+    const globOptions = {
+      dot: true,
+      nodir: true,
+      follow: true,
+      cwd: path.resolve(this.props.path, this.buildConfig.clientBuildOutputDir),
+    };
+    const files = glob.sync("**", globOptions);
+    const hash = crypto.createHash("sha1");
+    for (const file of files) {
+      hash.update(file);
     }
+    const buildId = hash.digest("hex");
+    Logger.debug(`Generated build ID ${buildId}`);
+    return buildId;
+  }
 }
 export const useSites = createAppContext(() => {
-    const sites = [];
-    return {
-        add(name, type, props) {
-            sites.push({ name, type, props });
-        },
-        get all() {
-            return sites;
-        },
-    };
+  const sites = [];
+  return {
+    add(name, type, props) {
+      sites.push({ name, type, props });
+    },
+    get all() {
+      return sites;
+    },
+  };
 });
diff --git a/support/remix-site-function/regional-server.js b/support/remix-site-function/regional-server.js
index ec824ddb5f6fca2b9735a306e77ce0043ceaae34..178c91b656c48c00ccb03892d6f438233f048c4c 100644
--- a/support/remix-site-function/regional-server.js
+++ b/support/remix-site-function/regional-server.js
@@ -10,9 +10,9 @@ import {
   Headers as NodeHeaders,
   Request as NodeRequest,
   createRequestHandler as createNodeRequestHandler,
-  readableStreamToString,
+  writeReadableStreamToWritable,
 } from "@remix-run/node";
-
+import { URL } from "url";
 // Import the server build that was produced by `remix build`;
 import * as remixServerBuild from "./index.js";
 
@@ -82,28 +82,54 @@ function isBinaryType(contentType) {
   return binaryTypes.some((t) => contentType.includes(t));
 }
 
-function convertApigRequestToNode(event) {
+/**
+ * A function that returns the value to use as `context` in route `loader` and
+ * `action` functions.
+ *
+ * You can think of this as an escape hatch that allows you to pass
+ * environment/platform-specific values through to your loader/action.
+ */
+
+/**
+ * Returns a request handler for Architect that serves the response using
+ * Remix.
+ */
+function createRequestHandler({
+  build,
+  getLoadContext,
+  mode = process.env.NODE_ENV,
+}) {
+  let handleRequest = createNodeRequestHandler(build, mode);
+
+  return async (event, responseStream, _context) => {
+    let request = createRemixRequest(event, responseStream);
+    let loadContext = getLoadContext?.(event);
+
+    let response = await handleRequest(request, loadContext);
+
+    return sendRemixResponse(response, responseStream);
+  };
+}
+
+function createRemixRequest(event, res) {
   if (event.headers["x-forwarded-host"]) {
     event.headers.host = event.headers["x-forwarded-host"];
   }
 
-  const search = event.rawQueryString.length ? `?${event.rawQueryString}` : "";
+  let search = event.rawQueryString.length ? `?${event.rawQueryString}` : "";
+
   const url = new URL(event.rawPath + search, `https://${event.headers.host}`);
-  const isFormData = event.headers["content-type"]?.includes(
+  let isFormData = event.headers["content-type"]?.includes(
     "multipart/form-data"
   );
 
-  // Build headers
-  const headers = new NodeHeaders();
-  for (let [header, value] of Object.entries(event.headers)) {
-    if (value) {
-      headers.append(header, value);
-    }
-  }
+  let controller = new AbortController();
+  res.on("close", () => controller.abort());
 
   return new NodeRequest(url.href, {
     method: event.requestContext.http.method,
-    headers,
+    headers: createRemixHeaders(event.headers, event.cookies),
+    signal: controller.signal,
     body:
       event.body && event.isBase64Encoded
         ? isFormData
@@ -113,52 +139,59 @@ function convertApigRequestToNode(event) {
   });
 }
 
-async function convertNodeResponseToApig(nodeResponse) {
-  const contentType = nodeResponse.headers.get("Content-Type");
-  const isBase64Encoded = isBinaryType(contentType);
+function createRemixHeaders(requestHeaders, requestCookies) {
+  let headers = new NodeHeaders();
 
-  // Build cookies
-  // note: AWS API Gateway will send back set-cookies outside of response headers.
-  const cookies = [];
-  for (let [key, values] of Object.entries(nodeResponse.headers.raw())) {
-    if (key.toLowerCase() === "set-cookie") {
-      for (let value of values) {
-        cookies.push(value);
-      }
+  for (let [header, value] of Object.entries(requestHeaders)) {
+    if (value) {
+      headers.append(header, value);
     }
   }
 
-  if (cookies.length) {
-    nodeResponse.headers.delete("Set-Cookie");
+  if (requestCookies) {
+    headers.append("Cookie", requestCookies.join("; "));
   }
 
-  // Build body
-  let body;
-  if (nodeResponse.body) {
-    if (isBase64Encoded) {
-      body = await readableStreamToString(nodeResponse.body, "base64");
-    } else {
-      body = await nodeResponse.text();
+  return headers;
+}
+
+async function sendRemixResponse(nodeResponse, res) {
+  let cookies = [];
+
+  // Lambda function urls return cookies outside of headers
+  for (let [key, value] of nodeResponse.headers.entries()) {
+    if (key.toLowerCase() === "set-cookie") {
+      cookies.push(value);
     }
   }
 
-  return {
+  if (cookies.length) {
+    nodeResponse.headers.delete("Set-Cookie");
+  }
+
+  let metadata = {
     statusCode: nodeResponse.status,
     headers: Object.fromEntries(nodeResponse.headers.entries()),
     cookies,
-    body,
-    isBase64Encoded,
   };
-}
 
-const createApigHandler = (build) => {
-  const requestHandler = createNodeRequestHandler(build, process.env.NODE_ENV);
+  let httpResponseStream = awslambda.HttpResponseStream.from(res, metadata);
 
-  return async (event) => {
-    const request = convertApigRequestToNode(event);
-    const response = await requestHandler(request);
-    return convertNodeResponseToApig(response);
-  };
-};
+  if (nodeResponse.body) {
+    await writeReadableStreamToWritable(nodeResponse.body, httpResponseStream);
+  } else {
+    res.end();
+  }
+}
 
-export const handler = createApigHandler(remixServerBuild);
+const requestHandler = createRequestHandler({
+  build: remixServerBuild,
+  mode: process.env.NODE_ENV,
+});
+
+export const handler = awslambda.streamifyResponse(
+  (event, response, context) => {
+    console.log("EVENT:", event);
+    return requestHandler(event, response, context);
+  }
+);